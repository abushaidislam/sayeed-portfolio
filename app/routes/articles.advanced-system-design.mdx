---
title: 'Advanced System Design: Scalable Architecture Patterns'
abstract: 'Explore enterprise-level system design patterns including CQRS, event sourcing, and distributed caching for building highly scalable applications.'
date: '2024-01-28'
banner: /articles/system-design-patterns/banner.jpg
featured: false
---

## Introduction

Building scalable systems requires understanding advanced architectural patterns that handle high traffic, maintain data consistency, and provide fault tolerance. This article covers enterprise-level patterns used by major tech companies.

## CQRS (Command Query Responsibility Segregation)

CQRS separates read and write operations, allowing independent optimization of each.

```javascript
// Command side - Write operations
class OrderCommandHandler {
  constructor(eventStore, eventBus) {
    this.eventStore = eventStore;
    this.eventBus = eventBus;
  }

  async createOrder(command) {
    const { customerId, items, totalAmount } = command;
    const orderId = generateId();
    
    const events = [
      {
        type: 'OrderCreated',
        aggregateId: orderId,
        data: { customerId, items, totalAmount, status: 'pending' },
        timestamp: new Date()
      }
    ];

    await this.eventStore.saveEvents(orderId, events);
    await this.eventBus.publish(events);
    
    return { orderId };
  }

  async updateOrderStatus(command) {
    const { orderId, status } = command;
    
    const events = [{
      type: 'OrderStatusUpdated',
      aggregateId: orderId,
      data: { status },
      timestamp: new Date()
    }];

    await this.eventStore.saveEvents(orderId, events);
    await this.eventBus.publish(events);
  }
}

// Query side - Read operations
class OrderQueryHandler {
  constructor(readDatabase) {
    this.db = readDatabase;
  }

  async getOrderById(orderId) {
    return await this.db.query(
      'SELECT * FROM order_views WHERE id = $1',
      [orderId]
    );
  }

  async getOrdersByCustomer(customerId, limit = 20) {
    return await this.db.query(`
      SELECT * FROM order_views 
      WHERE customer_id = $1 
      ORDER BY created_at DESC 
      LIMIT $2
    `, [customerId, limit]);
  }

  async getOrderStatistics(dateRange) {
    return await this.db.query(`
      SELECT 
        status,
        COUNT(*) as count,
        SUM(total_amount) as total_revenue
      FROM order_views 
      WHERE created_at BETWEEN $1 AND $2
      GROUP BY status
    `, [dateRange.start, dateRange.end]);
  }
}
```

## Event Sourcing Implementation

```javascript
class EventStore {
  constructor(database) {
    this.db = database;
  }

  async saveEvents(aggregateId, events) {
    const connection = await this.db.getConnection();
    
    try {
      await connection.beginTransaction();
      
      for (const event of events) {
        await connection.query(`
          INSERT INTO events (aggregate_id, event_type, event_data, version, timestamp)
          VALUES ($1, $2, $3, 
            (SELECT COALESCE(MAX(version), 0) + 1 FROM events WHERE aggregate_id = $1),
            $4)
        `, [aggregateId, event.type, JSON.stringify(event.data), event.timestamp]);
      }
      
      await connection.commit();
    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  }

  async getEvents(aggregateId, fromVersion = 0) {
    const result = await this.db.query(`
      SELECT event_type, event_data, version, timestamp
      FROM events 
      WHERE aggregate_id = $1 AND version > $2
      ORDER BY version ASC
    `, [aggregateId, fromVersion]);

    return result.rows.map(row => ({
      type: row.event_type,
      data: JSON.parse(row.event_data),
      version: row.version,
      timestamp: row.timestamp
    }));
  }
}

// Aggregate reconstruction from events
class OrderAggregate {
  constructor() {
    this.id = null;
    this.customerId = null;
    this.items = [];
    this.status = null;
    this.totalAmount = 0;
    this.version = 0;
  }

  static async fromEvents(eventStore, aggregateId) {
    const events = await eventStore.getEvents(aggregateId);
    const aggregate = new OrderAggregate();
    
    for (const event of events) {
      aggregate.apply(event);
    }
    
    return aggregate;
  }

  apply(event) {
    switch (event.type) {
      case 'OrderCreated':
        this.id = event.aggregateId;
        this.customerId = event.data.customerId;
        this.items = event.data.items;
        this.totalAmount = event.data.totalAmount;
        this.status = event.data.status;
        break;
        
      case 'OrderStatusUpdated':
        this.status = event.data.status;
        break;
    }
    
    this.version = event.version;
  }
}
```

## Distributed Caching with Redis Cluster

```javascript
class DistributedCache {
  constructor(redisClusterNodes) {
    this.cluster = new Redis.Cluster(redisClusterNodes, {
      redisOptions: {
        password: process.env.REDIS_PASSWORD,
      },
      retryDelayOnFailover: 100,
      maxRetriesPerRequest: 3
    });
    
    this.setupEventHandlers();
  }

  async get(key) {
    try {
      const value = await this.cluster.get(key);
      return value ? JSON.parse(value) : null;
    } catch (error) {
      console.error('Cache get error:', error);
      return null;
    }
  }

  async set(key, value, ttl = 3600) {
    try {
      await this.cluster.setex(key, ttl, JSON.stringify(value));
    } catch (error) {
      console.error('Cache set error:', error);
    }
  }

  async mget(keys) {
    try {
      const values = await this.cluster.mget(...keys);
      return values.map(value => value ? JSON.parse(value) : null);
    } catch (error) {
      console.error('Cache mget error:', error);
      return new Array(keys.length).fill(null);
    }
  }

  // Cache warming strategy
  async warmCache(dataLoader) {
    const keys = await dataLoader.getKeysToWarm();
    const batchSize = 100;
    
    for (let i = 0; i < keys.length; i += batchSize) {
      const batch = keys.slice(i, i + batchSize);
      
      await Promise.all(batch.map(async (key) => {
        try {
          const data = await dataLoader.loadData(key);
          await this.set(key, data, 7200); // 2 hours TTL
        } catch (error) {
          console.error(`Failed to warm cache for key ${key}:`, error);
        }
      }));
    }
  }

  setupEventHandlers() {
    this.cluster.on('error', (error) => {
      console.error('Redis cluster error:', error);
    });

    this.cluster.on('ready', () => {
      console.log('Redis cluster ready');
    });
  }
}
```

## API Rate Limiting and Circuit Breakers

```javascript
class RateLimiter {
  constructor(redisClient) {
    this.redis = redisClient;
  }

  async checkLimit(key, limit, windowSize) {
    const now = Date.now();
    const window = Math.floor(now / (windowSize * 1000));
    const redisKey = `rate_limit:${key}:${window}`;
    
    const pipeline = this.redis.pipeline();
    pipeline.incr(redisKey);
    pipeline.expire(redisKey, windowSize);
    
    const results = await pipeline.exec();
    const count = results[0][1];
    
    return {
      allowed: count <= limit,
      count,
      limit,
      resetTime: (window + 1) * windowSize * 1000
    };
  }
}

class APIGateway {
  constructor(rateLimiter, circuitBreaker) {
    this.rateLimiter = rateLimiter;
    this.circuitBreaker = circuitBreaker;
    this.services = new Map();
  }

  async handleRequest(req, res) {
    const clientId = this.getClientId(req);
    
    // Rate limiting
    const rateLimit = await this.rateLimiter.checkLimit(
      clientId, 
      1000, // 1000 requests
      3600  // per hour
    );
    
    if (!rateLimit.allowed) {
      return res.status(429).json({
        error: 'Rate limit exceeded',
        resetTime: rateLimit.resetTime
      });
    }

    // Circuit breaker protection
    try {
      const response = await this.circuitBreaker.execute(async () => {
        return await this.forwardRequest(req);
      });
      
      res.json(response);
    } catch (error) {
      res.status(503).json({
        error: 'Service temporarily unavailable'
      });
    }
  }

  getClientId(req) {
    return req.headers['x-api-key'] || req.ip;
  }
}
```

## Conclusion

Advanced system design patterns like CQRS, event sourcing, and distributed caching enable building highly scalable applications. These patterns provide:

- **Separation of Concerns**: CQRS separates read/write operations
- **Audit Trail**: Event sourcing provides complete history
- **Performance**: Distributed caching reduces latency
- **Resilience**: Circuit breakers prevent cascade failures

Choose patterns based on your specific requirements and start simple before adding complexity.