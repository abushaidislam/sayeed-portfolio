---
title: 'Advanced React Patterns: Compound Components and Render Props'
abstract: 'Explore sophisticated React design patterns including compound components, render props, and higher-order components to build more flexible and reusable UI libraries.'
date: '2024-01-15'
banner: /articles/advanced-react-patterns/banner.jpg
featured: false
---

## Introduction

React's component model enables powerful design patterns that can make your codebase more maintainable and flexible. In this article, we'll explore advanced patterns that React developers use to build scalable applications and reusable component libraries.

## Compound Components Pattern

The compound component pattern allows you to create components that work together as a cohesive unit while maintaining flexibility in their composition.

```jsx
// Modal compound component implementation
const Modal = ({ children, isOpen, onClose }) => {
  return (
    <ModalContext.Provider value={{ isOpen, onClose }}>
      <div className={`modal ${isOpen ? 'modal--open' : ''}`}>
        {children}
      </div>
    </ModalContext.Provider>
  );
};

Modal.Header = ({ children }) => {
  const { onClose } = useContext(ModalContext);
  return (
    <div className="modal__header">
      {children}
      <button onClick={onClose} className="modal__close">Ã—</button>
    </div>
  );
};

Modal.Body = ({ children }) => (
  <div className="modal__body">{children}</div>
);

Modal.Footer = ({ children }) => (
  <div className="modal__footer">{children}</div>
);

// Usage
function App() {
  const [isOpen, setIsOpen] = useState(false);
  
  return (
    <Modal isOpen={isOpen} onClose={() => setIsOpen(false)}>
      <Modal.Header>
        <h2>Confirmation</h2>
      </Modal.Header>
      <Modal.Body>
        <p>Are you sure you want to proceed?</p>
      </Modal.Body>
      <Modal.Footer>
        <button onClick={() => setIsOpen(false)}>Cancel</button>
        <button onClick={handleConfirm}>Confirm</button>
      </Modal.Footer>
    </Modal>
  );
}
```

## Render Props Pattern

Render props provide a way to share code between components using a prop whose value is a function.

```jsx
// Mouse tracker with render props
class MouseTracker extends Component {
  state = { x: 0, y: 0 };

  handleMouseMove = (event) => {
    this.setState({
      x: event.clientX,
      y: event.clientY
    });
  };

  render() {
    return (
      <div 
        style={{ height: '100vh' }} 
        onMouseMove={this.handleMouseMove}
      >
        {this.props.render(this.state)}
      </div>
    );
  }
}

// Usage with different rendering logic
function App() {
  return (
    <div>
      <MouseTracker
        render={({ x, y }) => (
          <h1>Mouse position: ({x}, {y})</h1>
        )}
      />
      
      <MouseTracker
        render={({ x, y }) => (
          <div 
            style={{
              position: 'absolute',
              left: x,
              top: y,
              width: 20,
              height: 20,
              backgroundColor: 'red',
              borderRadius: '50%'
            }}
          />
        )}
      />
    </div>
  );
}
```

## Higher-Order Components (HOCs)

HOCs are functions that take a component and return a new component with enhanced functionality.

```jsx
// Authentication HOC
function withAuth(WrappedComponent) {
  return function AuthenticatedComponent(props) {
    const [user, setUser] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
      const unsubscribe = auth.onAuthStateChanged((user) => {
        setUser(user);
        setLoading(false);
      });

      return unsubscribe;
    }, []);

    if (loading) {
      return <div>Loading...</div>;
    }

    if (!user) {
      return <LoginForm />;
    }

    return <WrappedComponent {...props} user={user} />;
  };
}

// Usage
const ProtectedDashboard = withAuth(Dashboard);
```

## Custom Hooks for Logic Reuse

Custom hooks allow you to extract component logic into reusable functions.

```jsx
// Custom hook for API data fetching
function useApi(url, options = {}) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    let cancelled = false;
    
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url, options);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (!cancelled) {
          setData(result);
          setError(null);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err.message);
          setData(null);
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    };

    fetchData();

    return () => {
      cancelled = true;
    };
  }, [url, JSON.stringify(options)]);

  return { data, loading, error };
}

// Usage in component
function UserProfile({ userId }) {
  const { data: user, loading, error } = useApi(`/api/users/${userId}`);

  if (loading) return <div>Loading user...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!user) return <div>User not found</div>;

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}
```

## Context API with useReducer

Combine Context API with useReducer for complex state management.

```jsx
// Theme context with reducer
const ThemeContext = createContext();

const themeReducer = (state, action) => {
  switch (action.type) {
    case 'SET_THEME':
      return { ...state, theme: action.payload };
    case 'TOGGLE_THEME':
      return { 
        ...state, 
        theme: state.theme === 'light' ? 'dark' : 'light' 
      };
    case 'SET_ACCENT_COLOR':
      return { ...state, accentColor: action.payload };
    default:
      return state;
  }
};

export function ThemeProvider({ children }) {
  const [state, dispatch] = useReducer(themeReducer, {
    theme: 'light',
    accentColor: '#007bff'
  });

  const setTheme = (theme) => {
    dispatch({ type: 'SET_THEME', payload: theme });
  };

  const toggleTheme = () => {
    dispatch({ type: 'TOGGLE_THEME' });
  };

  const setAccentColor = (color) => {
    dispatch({ type: 'SET_ACCENT_COLOR', payload: color });
  };

  return (
    <ThemeContext.Provider 
      value={{ 
        ...state, 
        setTheme, 
        toggleTheme, 
        setAccentColor 
      }}
    >
      {children}
    </ThemeContext.Provider>
  );
}

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};
```

## Error Boundaries

Error boundaries catch JavaScript errors anywhere in the component tree.

```jsx
class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    this.setState({
      error: error,
      errorInfo: errorInfo
    });
    
    // Log error to monitoring service
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>Something went wrong</h2>
          <details style={{ whiteSpace: 'pre-wrap' }}>
            {this.state.error && this.state.error.toString()}
          </details>
        </div>
      );
    }

    return this.props.children;
  }
}

// Usage
function App() {
  return (
    <ErrorBoundary>
      <Header />
      <Main />
      <Footer />
    </ErrorBoundary>
  );
}
```

## Performance Optimization Patterns

### React.memo and useMemo

```jsx
// Memoized component
const ExpensiveComponent = React.memo(({ data, filter }) => {
  const processedData = useMemo(() => {
    return data
      .filter(item => item.category === filter)
      .map(item => ({
        ...item,
        processed: heavyProcessing(item)
      }));
  }, [data, filter]);

  return (
    <div>
      {processedData.map(item => (
        <div key={item.id}>{item.name}</div>
      ))}
    </div>
  );
});

// Custom comparison function
const areEqual = (prevProps, nextProps) => {
  return (
    prevProps.data.length === nextProps.data.length &&
    prevProps.filter === nextProps.filter
  );
};

const OptimizedComponent = React.memo(ExpensiveComponent, areEqual);
```

## Conclusion

These advanced React patterns provide powerful tools for building scalable, maintainable applications. Compound components offer flexibility in composition, render props enable code sharing, and HOCs provide cross-cutting concerns. Combined with custom hooks and proper state management, these patterns form the foundation of professional React development.

The key is knowing when to use each pattern. Start simple and refactor to these patterns when you need the additional flexibility and reusability they provide.